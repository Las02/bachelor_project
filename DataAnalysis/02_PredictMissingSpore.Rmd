---
title: "03_random_forrest_spore"
output: html_document
date: "2023-04-06"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(magrittr)
library(tidymodels)
library(cowplot)
library(modelr)
library(naniar)
library(patchwork)
```

## Purpose
As sporeforming include a ton of missing values we build a model to predict spore formation to avoid missing values


## Reading in data
Before the analysis can continue we need to a little data wrangeling to get the correct format

```{r}
D <- readRDS("./data/bacdive_growth_ribdif.rds")

# For the pathogen column, set nan to 0
Dt_tmp1 <- D %>% 
  mutate(pathogen_any = ifelse(is.na(pathogen_any), "P0", pathogen_any))

# Set nan to neutrophile for PH.range
Dt_tmp2 <- Dt_tmp1 %>% 
  mutate(PH.range = ifelse(is.na(PH.range), "Pneutrophile", PH.range))

# Convert pseudogene to percent
Dt_tmp3 <- Dt_tmp2 %>% 
  mutate(pseudogenes_percent = 100*(pseudogenes/total_genes))

# Selecting only data in Bacillota or actinomycetota
D_all <- Dt_tmp3 %>%  
  filter(phylum %in% c("Bacillota","Actinomycetota")) %>% 
  select(species,last_col(42):last_col())  %>% 
  mutate(growth_temp = as.double(growth_temp)) 

# Filter out nans for sporeforming
D_filtered_tmp <- D_all %>% 
  filter(!is.na(sporeforming))

```


```{r}
# Select the data used for modelling
D_filtered <- D_filtered_tmp %>% 
  select(phylum, oxygen.tolerance, growth_temp,
         gc_percent, sporeforming, genes_coding, genome_components, pseudogenes_percent, ar_count) %>% 
  filter(if_all(everything(), ~!is.na(.x)))

```

### Spliting data

Using strata =, to make sure that spore forming is equally distributed in the test and training data set.

```{r}
set.seed(07042023)
D_split <- initial_split(D_filtered, prop = 0.80, strata = sporeforming)
D_train <- training(D_split) 
D_test <- testing(D_split)
```

### Setting up model

Based on: <https://juliasilge.com/blog/sf-trees-random-tuning/> 

```{r}
# setting up recipe
tree_rec <- recipe(sporeforming ~., data=D_train)

# Setting up model hyperparameters
tune_spec <- rand_forest(
  # number which can be sampled per tree
  mtry = tune(),
  trees = 1000,
  # min number of datapoints for a split being made 
  min_n = tune()
  ) %>%
  set_mode("classification") %>%
  set_engine("ranger")


# setting up workflow
tune_wf <- workflow() %>% 
  add_recipe(tree_rec) %>% 
  add_model(tune_spec)

```

## Tune hyperparameters

```{r}
# Set to parallel
doParallel::registerDoParallel()

# Make samples for cross-validation
trees_folds <- vfold_cv(D_train)

# Tune hyperparameters
# grid sets the number of grid points used
tune_res <- tune_grid(
  tune_wf,
  # Sets the 
  resamples = trees_folds,
  grid = 20
)

```

## Picking the best model

### First run

```{r}
tune_res %>%
  collect_metrics() %>%
  filter(.metric == "roc_auc") %>%
  select(mean, min_n, mtry) %>%
  pivot_longer(min_n:mtry,
    values_to = "value",
    names_to = "parameter"
  ) %>%
  ggplot(aes(value, mean, color = parameter)) +
  geom_point(show.legend = FALSE) +
  facet_wrap(~parameter, scales = "free_x") +
  labs(x = NULL, y = "AUC")
```

It seems that lower values of both the minimum numbers of data.points
per split (min_n) work better. And lower values of mtry, the number of
samples which can be choosen.

Lets try to run model on more values in this interval

### Second run

```{r}
# Making grid
rf_grid <- grid_regular(
  min_n(range = c(1,15)),
  mtry(range=c(1, 8)),
  levels = 5
)


regular_res <- tune_grid(
  tune_wf,
  resamples = trees_folds,
  grid = rf_grid
)

```

Results

```{r}
regular_res %>% 
  collect_metrics()

```

AUC

```{r}
regular_res %>%
  collect_metrics() %>%
  filter(.metric == "roc_auc") %>%
  mutate(min_n = factor(min_n)) %>%
  ggplot(aes(mtry, mean, color = min_n)) +
  geom_line(alpha = 0.5, size = 1.5) +
  geom_point() +
  labs(y = "AUC")
```


finalize the model, picking the best model found

```{r}
best_auc <- select_best(regular_res, "roc_auc")

final_rf <- finalize_model(
  tune_spec,
  best_auc
)

final_rf
```


## look at the most important predictors
```{r}
library(vip)

final_rf %>%
  set_engine("ranger", importance = "permutation") %>%
  fit(factor(sporeforming) ~ . ,data=D_train) %>%
  vip(geom = "point")
```


Now lets fit final data on entire training set and evaluate on the test data
```{r}
final_wf <- workflow() %>%
  add_recipe(tree_rec) %>%
  add_model(final_rf)

final_res <- final_wf %>%
  last_fit(D_split)

final_res %>%
  collect_metrics()

```

# And find the accuarsy
```{r}
final_res %>% 
  collect_predictions() %>% 
  filter(.pred_class != sporeforming)

# Only 6 wrong predictions out of 59 !!  = 0.93 accurcy..

```

## Running model on the rest of the data

```{r}
# Pick data for the predictions
D_to_pred <- D_all %>% 
  filter(is.na(sporeforming)) %>% 
  select(-sporeforming) %>% 
  select(species,phylum, oxygen.tolerance, growth_temp, n16, 
         gc_percent, genes_coding, genome_components,  pseudogenes_percent, ar_count) %>% 
  filter(if_all(everything(), ~!is.na(.x)))
  

```

Make predictions

```{r}
# Extract model
final_model <- final_res %>% 
  extract_model()

# Predict
predictions <- predict(final_model, D_to_pred, type="response")

# save in df
pred_df <- bind_cols(D_to_pred, predictions$predictions)

```

Plot the prediction confidence distribturion for all points and the roc curve

```{r}
# confidence distribution
p1 <- pred_df %>% 
  rename(sf0 = `0`, sf1 = `1`) %>% 
  mutate(best_pred = case_when(
    sf0 > sf1 ~ sf0,
    .default = sf1
  )) %>% 
  ggplot(aes(best_pred))+ geom_histogram()

# and roc curve for last predictions
p2 <- final_res %>% 
  collect_predictions() %>% 
  roc_curve(truth=sporeforming, .pred_0) %>% 
  autoplot() + geom_point(aes(y=sensitivity, x=1-specificity,col=.threshold))
 

p1 + p2
```

Based on above plots we picked a cutoff at 0.7. 
It seems like we get enough datapoints while still getting an ok quality of predictions
We then applied this threshold

```{r}
D_predicted <- pred_df %>% 
  rename(sf0 = `0`, sf1 = `1`) %>% 
  mutate(best_pred = case_when(
    sf0 > sf1 |sf0 > 0.7  ~ "p0",
    sf1 > sf0 | sf1 > 0.7 ~ "p1",
  )) 

```

Visualize predictions

```{r}


D_predicted %>% 
  ggplot(aes(x=genes_coding, y=n16, col=best_pred)) +
  geom_point() 
```

Join data again

```{r}
D_with_pred <- D_predicted %>% 
  select(species, best_pred) %>% 
  right_join(D, by="species")

# add sporeforming pred to normal sporeforming
D_final <- D_with_pred %>% 
  mutate(sporeforming = ifelse(is.na(sporeforming), best_pred, sporeforming))
           
  
```

Plot it finally (two different ways)

```{r}
D_final %>% 
  filter(phylum %in% c("Bacillota","Actinomycetota")) %>% 
  filter(!is.na(sporeforming)) %>% 
  ggplot(aes(x=genes_coding, y=n16, col=sporeforming)) +
  geom_point(size=1) +
  scale_color_manual(values = c("lightblue", "lightpink","blue","red")) +
  facet_wrap(~phylum)

D_final %>% 
  filter(phylum %in% c("Bacillota","Actinomycetota")) %>% 
  filter(!is.na(sporeforming)) %>% 
  mutate(sf_is_predicted = ifelse(sporeforming == "p1"|sporeforming =="p2", "yes","no")) %>% 
  mutate(sporeforming = ifelse(sporeforming == "1" | sporeforming == "p1", "1", 0)) %>% 
  ggplot(aes(x=genes_coding, y=n16, col=sporeforming, shape = sf_is_predicted)) +
  geom_jitter(size=1, height = 0.1) +
  facet_wrap(~phylum)
```

Inspect some entries on google.. It seems to be working :)) Both for spore forming and non spore forming
```{r}
D_final %>% 
  filter(sporeforming == "p1")

D_final %>% 
  filter(sporeforming == "p0")
```

Looking at missing data nbefore and after

```{r}

p1 <- D_final %>% 
  select(phylum,sporeforming, oxygen.tolerance, growth_temp) %>% 
  filter(phylum %in% c("Bacillota","Actinomycetota")) %>% 
   vis_miss(cluster = T, sort_miss = T) +
    theme(
        plot.margin = margin(, 1.5, , , "cm")
  ) + ggtitle("after")
  
p2 <- D %>% 
  select(phylum,sporeforming, oxygen.tolerance, growth_temp) %>% 
    filter(phylum %in% c("Bacillota","Actinomycetota")) %>% 
   vis_miss(cluster = T, sort_miss = T) +
    theme(
        plot.margin = margin(, 1.5, , , "cm")
  ) + ggtitle("before")

p2 + p1
```

## Lastly we set the gram negative entries to non-sporeforming. The argument for this can be found in the report.

```{r}

# Defining the phyla
has_sporeforming <- c("Bacillota","Actinomycetota")

# setting the others to not sporeforming
# They are all set to different values to differentiate where they came from eg, 1, 0, na0, p1 and p0 for statistics
D_final_many <- D_final %>% 
  mutate(sporeforming = case_when(
    phylum %in% has_sporeforming ~ sporeforming,
    sporeforming != NA ~ "20",
    .default = "na0"
  ))

D_final_many %>% 
  filter(phylum %in% has_sporeforming) %>% 
  ggplot(aes(phylum, fill = sporeforming)) + 
  geom_bar() 
```


```{r}
# Now cluster down the predicted to just 0 and 1
D_to_print <- D_final_many %>% 
  mutate(sporeforming = case_when(
    sporeforming == "p0" ~ "0",
    sporeforming == "p1" ~ "1",
    sporeforming == "na0" ~ "0",
    .default = sporeforming
  ))


```

#

Write it to file
and vizualise the missing values. Now it looks  better!
```{r}
D_to_print %>% 
  select(oxygen.tolerance, growth_temp, sporeforming) %>% 
  vis_miss(cluster=T)

saveRDS(D_to_print, file = "./data/pred_bacdive_growth_ribdif.rds")
hist(D_to_print$ar_count)
```
